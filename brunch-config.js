// brunch-config.js for brunch-test by cxw42

// How to extract common modules:
//  - set files.javascripts.joinTo to a string
//  - npx brunch b -e page1  2>&1 1>/dev/null|sort|uniq > page1-deps.txt
//  - npx brunch b -e page2  2>&1 1>/dev/null|sort|uniq > page2-deps.txt
//  - perl find-common.pl page*-deps.txt >> brunch-config.js
//  - change files.javascripts.joinTo to an object including 'app.js':/^app/
//  - Move the two RegExp() patterns from the end of brunch-config.js
//    (generated by find-common) into the files.javascripts.joinTo section.
//    'common.js' matches all the scripts used by multiple dependencies.
//    'app-specific.js' matches everything except for those and what's under
//    app/.
//  - npx brunch b -e page1
//  - npx brunch b -e page2
//  - diff public/page1/common.js public/page2/common.js && echo OK\!
//    ... which it will be, since both common.js files were generated from
//    the same list of files.  Then you can use either common.js you want.
//  TODO automate this :) .

// Note: in a Node console, this works:
// b = require('brunch');
// b.build(undefined, {env: 'page1'});
// b.build(undefined, {env: 'page2'});
// So I could have the onCompile handler write to a JSON file, and have
// this file read the JSON, do the uniqueness check, and make the regexes.

//console.dir(process.argv,{depth:null});
//console.dir(process.env,{depth:null});

const cli_opts = require('./brunch-options');
let env = (cli_opts.parsed_build[1] || {}).env;
    // parsed_build[1] because parsed_build[0] is the path, if one was
    // specified on the command line.  parsed_build[1] is the Options argument.

if(!env) {
    console.error('Run with -e page1 or -e page2');
    module.exports = null;
    return;
}
console.log('Env is ' + env);

// Tweaked from code by David Walsh,
// from https://davidwalsh.name/nested-objects , MIT license
var Objectifier = (function() {

    // Utility method to get and set objects that may or may not exist
    var objectifier = function(splits, create, context) {
        var result = context || global || window;
        for(var i = 0, s; result && (s = splits[i]); i++) {
            result = (s in result ? result[s] : (create ? result[s] = {} : undefined));
        }
        return result;
    };

    return {
        // Creates an object if it doesn't already exist
        set: function(name, value, context) {
            var splits = name.split('.'), s = splits.pop(), result = objectifier(splits, true, context);
            return result && s ? (result[s] = value) : undefined;
        },
        get: function(name, create, context) {
            return objectifier(name.split('.'), create, context);
        },
        exists: function(name, context) {
            return this.get(name, false, context) !== undefined;
        }
    };

})();

// Make our wrapped files stand out a bit more in the generated source
let seen_modules = Object.create(null);
    // to count how many times each file is processed

function wrapper(path, data)
{
    seen_modules[path] = (seen_modules[path] || 0) + 1;
    //console.log(`Wrapping ${path}; time #${seen_modules[path]}`);

    let retval = '\n// WRAPPED ' + `${path} #${seen_modules[path]}` +
        ' /////////////////////////////////\n';

    // Add the commonjs wrapper - copied from
    // https://github.com/brunch/brunch/blob/95902d9c24efb61e613c6c45bc6a33b819ec51ee/lib/utils/modules.js#L7
    retval += `
require.register("${path}", function(exports, require, module) {
${data}
});\n\n`

    retval += '\n/////////////////////////////////\n\n';
    return retval;
} //wrapper

// Trim module names in lib/ so that we can require('foo') rather than
// require('lib/foo').  See, e.g., https://stackoverflow.com/q/18859007/2877364
function nameCleaner(path)
{
    return path.replace(/^(app|lib)\//,'');
        // app/ is trimmed by default, so keep it in there.

    // node_modules support is built in to brunch, so we don't have to
    // handle it here.
} //nameCleaner

// === The config ===============================================

// --- General settings --------------------------
let config = {
    paths: {
        // Bundle from these:
        watched: ['lib', 'vendor', 'wapp', 'test'],
            // All of these will be wrapped, except for those matching
            // conventions.vendor below.
    },

    files: {
        javascripts: {
            joinTo: {
                'app.js': /^app/,
                // regexes generated by find-common.pl
                'common.js': new RegExp('^(?:lib/simpletest/index.js|vendor/foo.js|wapp/test.js|node_modules/simpletestnm/index.js|lib/multidex/index.js|lib/simpletest/lib/inner.js)'),
                '3rdparty.js': new RegExp('^(?!(?:app|lib/simpletest/index.js|vendor/foo.js|wapp/test.js|node_modules/simpletestnm/index.js|lib/multidex/index.js|lib/simpletest/lib/inner.js))'),
            },
        },
    },

    conventions: {
        // Don't wrap the following in modules:
        vendor: [ /(^bower_components|node_modules|vendor|^wapp)\// ],
            // default, plus ^wapp.  Note, however, that node_modules
            // appears to be handled specially by
            // https://github.com/brunch/deppack so that CommonJS modules
            // can be used in the browser.
            //
            // In this example, lib/ is watched but is not a vendor directory.
            // Therefore, modules in lib/ are wrapped.
    },

    // Use the helpers we defined above
    modules: {

        // Special wrapper that adds names
        wrapper,    // Note: only applies to things that get wrapped,
                    // i.e., non-`vendor`.

        // Map lib/foo->foo
        nameCleaner,
    },

    plugins: {
        replacer: {     // Permit using __filename in modules
            dict: [
                {
                    key: /\b__filename\b/,
                    // No value needed - the custom replacer below supplies it
                }
            ],
            replace: (str, key, value, path) => {
                //console.log(`Replacing in ${path}`);
                return str.split(key).join(`'${path}'`)
            }
        },
    },

    overrides: {
        production: {       // Always generate source maps, even in production
            sourceMaps: true,
        },
    },

    hooks: {
        // Report the filenames we used so that we can stash them for
        // find-common.pl to use.
        onCompile(generatedFiles, assets) {
            console.log('=== generatedFiles nicely');
            for(let tgt of generatedFiles) {
                console.log(`\nTarget ${tgt.path} depends on:`);
                for(let src of tgt.sourceFiles) {
                    console.error(`${tgt.path}\t${src.path}`);
                    // console.error() so you can do
                    // npx brunch b -e page2  2>&1 1>/dev/null|sort|uniq
                    // to get a list of the dependencies.
                }
            }
            //console.log('=== generatedFiles');
            //console.dir(generatedFiles, {depth:null});
            //console.log('=== assets');
            //console.dir(assets, {depth:null});
        },
    },
};

// --- Page-specific settings --------------------
let set = (path,val) => Objectifier.set(path, val, config.overrides);

set('page1.paths.watched', config.paths.watched.concat(['app/page1']));
set('page1.paths.public', 'public/page1', config.overrides);

set('page2.paths.watched', config.paths.watched.concat(['app/page2']));
set('page2.paths.public', 'public/page2');

module.exports = config;

// vi: set ts=4 sts=4 sw=4 et ai: //
